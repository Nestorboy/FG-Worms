#pragma kernel CSMain

#include "Assets/Scripts/Terrain/Marching Table.cginc"
#include "Assets/Scripts/Terrain/Marching Utils.cginc"

struct Triangle
{
    float3 verts[3];
};

struct Cell
{
    Triangle triangles[5];
    float weights[8];
};

uint3 Dimensions;

AppendStructuredBuffer<Triangle> CellBuffer;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 coord = float3(id) / Dimensions;
    float4 invDim = float4(0, 1.0 / Dimensions);

    Cell cell;
    int caseIndex = 0;
    for (int i = 0; i < 8; i++)
    {
        float3 offset =  float3(
            invDim[i>>0&1 ? 1 : 0],
            invDim[i>>1&1 ? 2 : 0],
            invDim[i>>2&1 ? 3 : 0]
            );

        float weight = noise(coord + offset);
        cell.weights[i] = weight;
        caseIndex |= (weight > 0) << i;
    }

    // Check for fully inside or outside.
    if (EdgeTable[caseIndex] == 0)
        return;

    for (int i = 0; VertTable[caseIndex][i] > -1; i += 3)
    {
        uint2 e1 = uint2(
            cornerIndexAFromEdge[VertTable[caseIndex][i+0]],
            cornerIndexBFromEdge[VertTable[caseIndex][i+0]]
            );
        uint2 e2 = uint2(
            cornerIndexAFromEdge[VertTable[caseIndex][i+1]],
            cornerIndexBFromEdge[VertTable[caseIndex][i+1]]
            );
        uint2 e3 = uint2(
            cornerIndexAFromEdge[VertTable[caseIndex][i+2]],
            cornerIndexBFromEdge[VertTable[caseIndex][i+2]]
            );
        
        Triangle tri;
        //tri.verts[0] = invLerp(cell[]);
        CellBuffer.Append(tri);
    }
}